"""
Git operations manager for CodeWiki CLI.
"""

from pathlib import Path
from datetime import datetime
from typing import Optional, Tuple
import git
from git.exc import GitCommandError

from codewiki.cli.utils.errors import RepositoryError


class GitManager:
    """
    Manages git operations for documentation generation.
    
    Handles:
    - Status checking
    - Branch creation
    - Committing documentation
    - Remote detection
    """
    
    def __init__(self, repo_path: Path):
        """
        Initialize git manager.
        
        Args:
            repo_path: Path to git repository
            
        Raises:
            RepositoryError: If not a valid git repository
        """
        self.repo_path = Path(repo_path).expanduser().resolve()
        
        try:
            self.repo = git.Repo(repo_path, search_parent_directories=True)
        except git.InvalidGitRepositoryError:
            raise RepositoryError(
                f"Not a git repository: {repo_path}\n\n"
                "To initialize a git repository: git init"
            )
    
    def check_clean_working_directory(self) -> Tuple[bool, str]:
        """
        Check if working directory is clean (no uncommitted changes).
        
        Returns:
            Tuple of (is_clean, status_message)
        """
        if self.repo.is_dirty(untracked_files=True):
            status_lines = []
            
            # Changed files
            changed = [item.a_path for item in self.repo.index.diff(None)]
            if changed:
                status_lines.append(f"Modified: {', '.join(changed[:3])}")
                if len(changed) > 3:
                    status_lines.append(f"... and {len(changed) - 3} more")
            
            # Untracked files
            untracked = self.repo.untracked_files
            if untracked:
                status_lines.append(f"Untracked: {', '.join(untracked[:3])}")
                if len(untracked) > 3:
                    status_lines.append(f"... and {len(untracked) - 3} more")
            
            return False, "\n".join(status_lines)
        
        return True, "Working directory is clean"
    
    def create_documentation_branch(self, force: bool = False) -> str:
        """
        Create a new documentation branch with timestamp.
        
        Args:
            force: Force creation even if dirty working directory
            
        Returns:
            Branch name
            
        Raises:
            RepositoryError: If working directory is dirty (unless force=True)
        """
        # Check working directory
        if not force:
            is_clean, status_msg = self.check_clean_working_directory()
            if not is_clean:
                raise RepositoryError(
                    "Working directory has uncommitted changes.\n\n"
                    f"{status_msg}\n\n"
                    "Cannot create documentation branch with uncommitted changes.\n"
                    "Please commit or stash your changes first:\n"
                    "  git status\n"
                    "  git add -A && git commit -m \"Your message\"\n"
                    "  # or\n"
                    "  git stash\n\n"
                    "Then re-run: codewiki generate --create-branch"
                )
        
        # Generate branch name with timestamp
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        branch_name = f"docs/codewiki-{timestamp}"
        
        # Check if branch already exists (shouldn't happen with timestamp)
        existing_branches = [b.name for b in self.repo.branches]
        if branch_name in existing_branches:
            # Append counter
            counter = 1
            while f"{branch_name}-{counter}" in existing_branches:
                counter += 1
            branch_name = f"{branch_name}-{counter}"
        
        try:
            # Create and checkout new branch
            new_branch = self.repo.create_head(branch_name)
            new_branch.checkout()
            return branch_name
        except GitCommandError as e:
            raise RepositoryError(f"Failed to create branch: {e}")
    
    def commit_documentation(
        self,
        docs_path: Path,
        message: Optional[str] = None
    ) -> str:
        """
        Commit generated documentation.
        
        Args:
            docs_path: Path to documentation directory
            message: Commit message (optional)
            
        Returns:
            Commit hash
            
        Raises:
            RepositoryError: If commit fails
        """
        if message is None:
            message = "Add generated documentation\n\nGenerated by CodeWiki CLI"
        
        try:
            # Add documentation files
            self.repo.index.add([str(docs_path)])
            
            # Commit
            commit = self.repo.index.commit(message)
            
            return commit.hexsha
        except GitCommandError as e:
            raise RepositoryError(f"Failed to commit documentation: {e}")
    
    def get_remote_url(self, remote_name: str = "origin") -> Optional[str]:
        """
        Get remote repository URL.
        
        Args:
            remote_name: Name of remote (default: origin)
            
        Returns:
            Remote URL or None if no remote
        """
        try:
            remote = self.repo.remote(remote_name)
            return remote.url
        except ValueError:
            return None
    
    def get_current_branch(self) -> str:
        """
        Get current branch name.
        
        Returns:
            Branch name
        """
        try:
            return self.repo.active_branch.name
        except TypeError:
            # Detached HEAD
            return "HEAD"
    
    def get_commit_hash(self) -> str:
        """
        Get current commit hash.
        
        Returns:
            Commit hash
        """
        return self.repo.head.commit.hexsha
    
    def branch_exists(self, branch_name: str) -> bool:
        """
        Check if a branch exists.
        
        Args:
            branch_name: Branch name to check
            
        Returns:
            True if exists, False otherwise
        """
        return branch_name in [b.name for b in self.repo.branches]
    
    def get_github_pr_url(self, branch_name: str) -> Optional[str]:
        """
        Get GitHub PR creation URL for a branch.
        
        Args:
            branch_name: Branch name
            
        Returns:
            PR URL or None if not a GitHub repo
        """
        remote_url = self.get_remote_url()
        if not remote_url or "github.com" not in remote_url:
            return None
        
        # Clean URL
        base_url = remote_url.rstrip('/').replace('.git', '')
        
        # Convert SSH to HTTPS
        if base_url.startswith('git@github.com:'):
            base_url = base_url.replace('git@github.com:', 'https://github.com/')
        
        return f"{base_url}/compare/{branch_name}"

